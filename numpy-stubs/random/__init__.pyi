import builtins
from typing import (
    Any,
    List,
    overload,
    Optional,
    Sequence,
    Tuple,
    TypeVar,
    Union,
)
from numpy import ndarray
from . import mtrand

_Size = Union[int, Sequence[int]]
_T = TypeVar("_T")
_ArrayLike = Union[Sequence[_T], ndarray]
_ScalarOrArray = Union[_T, Sequence[_T], ndarray]
RandomState = mtrand.RandomState
@overload
def beta(a: float, b: float, size: None = ...) -> float: ...
@overload
def beta(
    a: _ScalarOrArray[float], b: _ScalarOrArray[float], size: _Size
) -> ndarray: ...
@overload
def beta(a: _ArrayLike[float], b: float, size: None = ...) -> ndarray: ...
@overload
def beta(a: float, b: _ArrayLike[float], size: None = ...) -> ndarray: ...
@overload
def beta(
    a: _ArrayLike[float], b: _ArrayLike[float], size: None = ...
) -> ndarray: ...
def bytes(length: int) -> builtins.bytes: ...
@overload
def binomial(n: int, p: float, size: None = ...) -> int: ...
@overload
def binomial(
    n: _ScalarOrArray[int], p: _ScalarOrArray[float], size: _Size
) -> ndarray: ...
@overload
def binomial(n: _ArrayLike[int], p: float, size: None = ...) -> ndarray: ...
@overload
def binomial(n: int, p: _ArrayLike[float], size: None = ...) -> ndarray: ...
@overload
def binomial(
    n: _ArrayLike[int], p: _ArrayLike[float], size: None = ...
) -> ndarray: ...
@overload
def chisquared(df: int, size: None = ...) -> float: ...
@overload
def chisquared(df: _ScalarOrArray[int], size: _Size) -> ndarray: ...
@overload
def chisquared(df: _ArrayLike[int], size: None = ...) -> ndarray: ...
@overload
def choice(
    a: int,
    size: None = ...,
    replace: bool = ...,
    p: Optional[_ArrayLike[float]] = ...,
) -> int: ...
@overload
def choice(
    a: Sequence[_T],
    size: None = ...,
    replace: bool = ...,
    p: Optional[_ArrayLike[float]] = ...,
) -> _T: ...
@overload
def choice(
    a: ndarray,
    size: None = ...,
    replace: bool = ...,
    p: Optional[_ArrayLike[float]] = ...,
) -> Any: ...
@overload
def choice(
    a: Union[int, ndarray],
    size: _Size,
    replace: bool = ...,
    p: Optional[_ArrayLike[float]] = ...,
) -> ndarray: ...
def dirichlet(
    alpha: _ArrayLike[float], size: Optional[_Size] = ...
) -> ndarray: ...
@overload
def exponential(scale: float = ..., size: None = ...) -> float: ...
@overload
def exponential(scale: _ScalarOrArray[float], size: _Size) -> ndarray: ...
@overload
def exponential(scale: _ArrayLike[float], size: None = ...) -> ndarray: ...
@overload
def f(dfnum: float, dfden: float, size: None = ...) -> float: ...
@overload
def f(
    dfnum: _ScalarOrArray[float], dfden: _ScalarOrArray[float], size: _Size
) -> ndarray: ...
@overload
def f(dfnum: _ArrayLike[float], dfden: float, size: None = ...) -> ndarray: ...
@overload
def f(dfnum: float, dfden: _ArrayLike[float], size: None = ...) -> ndarray: ...
@overload
def f(
    dfnum: _ArrayLike[float], dfden: _ArrayLike[float], size: None = ...
) -> ndarray: ...
@overload
def gamma(shape: float, scale: float = ..., size: None = ...) -> float: ...
@overload
def gamma(
    shape: _ScalarOrArray[float], scale: _ScalarOrArray[float], size: _Size
) -> ndarray: ...
@overload
def gamma(
    shape: _ArrayLike[float], scale: float, size: None = ...
) -> ndarray: ...
@overload
def gamma(
    shape: float, scale: _ArrayLike[float], size: None = ...
) -> ndarray: ...
@overload
def gamma(
    shape: _ArrayLike[float], scale: _ArrayLike[float], size: None = ...
) -> ndarray: ...
@overload
def geometric(p: float, size: None = ...) -> float: ...
@overload
def geometric(p: _ScalarOrArray[float], size: _Size) -> ndarray: ...
@overload
def geometric(p: _ArrayLike[float], size: None = ...) -> ndarray: ...
def get_state() -> Tuple[str, ndarray, int, int, float]: ...
@overload
def gumbel(
    loc: float = ..., scale: float = ..., size: None = ...
) -> float: ...
@overload
def gumbel(
    loc: _ScalarOrArray[float], scale: _ScalarOrArray[float], size: _Size
) -> ndarray: ...
@overload
def gumbel(
    loc: _ArrayLike[float], scale: float, size: None = ...
) -> ndarray: ...
@overload
def gumbel(
    loc: float, scale: _ArrayLike[float], size: None = ...
) -> ndarray: ...
@overload
def gumbel(
    loc: _ArrayLike[float], scale: _ArrayLike[float], size: None = ...
) -> ndarray: ...
@overload
def hypergeometric(
    ngood: int, nbad: int, nsample: int, size: None = ...
) -> int: ...
@overload
def hypergeometric(
    ngood: _ScalarOrArray[int],
    nbad: _ScalarOrArray[int],
    nsample: _ScalarOrArray[int],
    size: _Size,
) -> ndarray: ...
@overload
def hypergeometric(
    ngood: _ArrayLike[int], nbad: int, nsample: int, size: None = ...
) -> ndarray: ...
@overload
def hypergeometric(
    ngood: int, nbad: _ArrayLike[int], nsample: int, size: None = ...
) -> ndarray: ...
@overload
def hypergeometric(
    ngood: int, nbad: int, nsample: _ArrayLike[int], size: None = ...
) -> ndarray: ...
@overload
def hypergeometric(
    ngood: _ArrayLike[int],
    nbad: _ArrayLike[int],
    nsample: int,
    size: None = ...,
) -> ndarray: ...
@overload
def hypergeometric(
    ngood: _ArrayLike[int],
    nbad: int,
    nsample: _ArrayLike[int],
    size: None = ...,
) -> ndarray: ...
@overload
def hypergeometric(
    ngood: int,
    nbad: _ArrayLike[int],
    nsample: _ArrayLike[int],
    size: None = ...,
) -> ndarray: ...
@overload
def hypergeometric(
    ngood: _ArrayLike[int],
    nbad: _ArrayLike[int],
    nsample: _ArrayLike[int],
    size: None = ...,
) -> ndarray: ...
@overload
def laplace(
    loc: float = ..., scale: float = ..., size: None = ...
) -> float: ...
@overload
def laplace(
    loc: _ScalarOrArray[float], scale: _ScalarOrArray[float], size: _Size
) -> ndarray: ...
@overload
def laplace(
    loc: _ArrayLike[float], scale: float, size: None = ...
) -> ndarray: ...
@overload
def laplace(
    loc: float, scale: _ArrayLike[float], size: None = ...
) -> ndarray: ...
@overload
def laplace(
    loc: _ArrayLike[float], scale: _ArrayLike[float], size: None = ...
) -> ndarray: ...
@overload
def logistic(
    loc: float = ..., scale: float = ..., size: None = ...
) -> float: ...
@overload
def logistic(
    loc: _ScalarOrArray[float], scale: _ScalarOrArray[float], size: _Size
) -> ndarray: ...
@overload
def logistic(
    loc: _ArrayLike[float], scale: float, size: None = ...
) -> ndarray: ...
@overload
def logistic(
    loc: float, scale: _ArrayLike[float], size: None = ...
) -> ndarray: ...
@overload
def logistic(
    loc: _ArrayLike[float], scale: _ArrayLike[float], size: None = ...
) -> ndarray: ...
@overload
def lognormal(
    mean: float = ..., sigma: float = ..., size: None = ...
) -> float: ...
@overload
def lognormal(
    mean: _ScalarOrArray[float], sigma: _ScalarOrArray[float], size: _Size
) -> ndarray: ...
@overload
def lognormal(
    mean: _ArrayLike[float], sigma: float, size: None = ...
) -> ndarray: ...
@overload
def lognormal(
    mean: float, sigma: _ArrayLike[float], size: None = ...
) -> ndarray: ...
@overload
def lognormal(
    mean: _ArrayLike[float], sigma: _ArrayLike[float], size: None = ...
) -> ndarray: ...
@overload
def logseries(p: float, size: None = ...) -> int: ...
@overload
def logseries(p: _ScalarOrArray[float], size: _Size) -> ndarray: ...
@overload
def logseries(p: _ArrayLike[float], size: None = ...) -> ndarray: ...
def multinomial(n: int, size: Optional[_Size] = ...) -> ndarray: ...
def multivariate_normal(
    mean: ndarray,
    cov: ndarray,
    size: Optional[_Size] = ...,
    check_valid: str = ...,
    tol: float = ...,
) -> ndarray: ...
@overload
def negative_binomial(n: int, p: float, size: None = ...) -> int: ...
@overload
def negative_binomial(
    n: _ScalarOrArray[int], p: _ScalarOrArray[float], size: _Size
) -> ndarray: ...
@overload
def negative_binomial(
    n: _ArrayLike[int], p: float, size: None = ...
) -> ndarray: ...
@overload
def negative_binomial(
    n: int, p: _ArrayLike[float], size: None = ...
) -> ndarray: ...
@overload
def negative_binomial(
    n: _ArrayLike[int], p: _ArrayLike[float], size: None = ...
) -> ndarray: ...
@overload
def noncentral_chisquare(
    df: float, nonc: float, size: None = ...
) -> float: ...
@overload
def noncentral_chisquare(
    df: _ScalarOrArray[float], nonc: _ScalarOrArray[float], size: _Size
) -> ndarray: ...
@overload
def noncentral_chisquare(
    df: _ArrayLike[float], nonc: float, size: None = ...
) -> ndarray: ...
@overload
def noncentral_chisquare(
    df: float, nonc: _ArrayLike[float], size: None = ...
) -> ndarray: ...
@overload
def noncentral_chisquare(
    df: _ArrayLike[float], nonc: _ArrayLike[float], size: None = ...
) -> ndarray: ...
@overload
def noncentral_f(
    dfnum: float, dfden: float, nonc: float, size: None = ...
) -> float: ...
@overload
def noncentral_f(
    dfnum: _ScalarOrArray[float],
    dfden: _ScalarOrArray[float],
    nonc: _ScalarOrArray[float],
    size: _Size,
) -> ndarray: ...
@overload
def noncentral_f(
    dfnum: _ArrayLike[float], dfden: float, nonc: float, size: None = ...
) -> ndarray: ...
@overload
def noncentral_f(
    dfnum: float, dfden: _ArrayLike[float], nonc: float, size: None = ...
) -> ndarray: ...
@overload
def noncentral_f(
    dfnum: float, dfden: float, nonc: _ArrayLike[float], size: None = ...
) -> ndarray: ...
@overload
def noncentral_f(
    dfnum: _ArrayLike[float],
    dfden: _ArrayLike[float],
    nonc: float,
    size: None = ...,
) -> ndarray: ...
@overload
def noncentral_f(
    dfnum: _ArrayLike[float],
    dfden: float,
    nonc: _ArrayLike[float],
    size: None = ...,
) -> ndarray: ...
@overload
def noncentral_f(
    dfnum: float,
    dfden: _ArrayLike[float],
    nonc: _ArrayLike[float],
    size: None = ...,
) -> ndarray: ...
@overload
def noncentral_f(
    dfnum: _ArrayLike[float],
    dfden: _ArrayLike[float],
    nonc: _ArrayLike[float],
    size: None = ...,
) -> ndarray: ...
@overload
def normal(
    loc: float = ..., scale: float = ..., size: None = ...
) -> float: ...
@overload
def normal(
    loc: _ScalarOrArray[float], scale: _ScalarOrArray[float], size: _Size
) -> ndarray: ...
@overload
def normal(
    loc: _ArrayLike[float], scale: float, size: None = ...
) -> ndarray: ...
@overload
def normal(
    loc: float, scale: _ArrayLike[float], size: None = ...
) -> ndarray: ...
@overload
def normal(
    loc: _ArrayLike[float], scale: _ArrayLike[float], size: None = ...
) -> ndarray: ...
@overload
def pareto(a: float, size: None = ...) -> float: ...
@overload
def pareto(a: _ScalarOrArray[float], size: _Size) -> ndarray: ...
@overload
def pareto(a: _ArrayLike[float], size: None = ...) -> ndarray: ...
def permutation(x: Union[int, ndarray]) -> ndarray: ...
@overload
def poisson(lam: float = ..., size: None = ...) -> float: ...
@overload
def poisson(lam: _ScalarOrArray[float], size: _Size) -> ndarray: ...
@overload
def poisson(lam: _ArrayLike[float], size: None = ...) -> ndarray: ...
@overload
def power(a: float, size: None = ...) -> float: ...
@overload
def power(a: _ScalarOrArray[float], size: _Size) -> ndarray: ...
@overload
def power(a: _ArrayLike[float], size: None = ...) -> ndarray: ...
@overload
def rand() -> float: ...
@overload
def rand(d0: int, *dn: int) -> ndarray: ...
@overload
def randint(low: int, high: int = ..., size: None = ...) -> int: ...
@overload
def randint(
    low: _ScalarOrArray[int], high: _ScalarOrArray[int], size: _Size
) -> ndarray: ...
@overload
def randint(low: _ArrayLike[int], high: int, size: None = ...) -> ndarray: ...
@overload
def randint(low: int, high: _ArrayLike[int], size: None = ...) -> ndarray: ...
@overload
def randint(
    low: _ArrayLike[int], high: _ArrayLike[int], size: None = ...
) -> ndarray: ...
@overload
def randn() -> float: ...
@overload
def randn(d0: int, *dn: int) -> ndarray: ...
@overload
def random_integers(low: int, high: int = ..., size: None = ...) -> int: ...
@overload
def random_integers(
    low: _ScalarOrArray[int], high: _ScalarOrArray[int], size: _Size
) -> ndarray: ...
@overload
def random_integers(
    low: _ArrayLike[int], high: int, size: None = ...
) -> ndarray: ...
@overload
def random_integers(
    low: int, high: _ArrayLike[int], size: None = ...
) -> ndarray: ...
@overload
def random_integers(
    low: _ArrayLike[int], high: _ArrayLike[int], size: None = ...
) -> ndarray: ...
@overload
def random_sample(size: None = ...) -> int: ...
@overload
def random_sample(size: _Size) -> ndarray: ...
@overload
def rayleigh(scale: float, size: None = ...) -> float: ...
@overload
def rayleigh(scale: _ScalarOrArray[float], size: _Size) -> ndarray: ...
@overload
def rayleigh(scale: _ArrayLike[float], size: None = ...) -> ndarray: ...
def seed(seed: Union[None, int, Tuple[int], List[int]] = ...) -> None: ...
def set_state(state: Tuple[str, ndarray, int, int, float]) -> None: ...
def shuffle(x: _ArrayLike[Any]) -> None: ...
@overload
def standard_cauchy(size: None = ...) -> float: ...
@overload
def standard_cauchy(size: _Size) -> ndarray: ...
@overload
def standard_exponential(size: None = ...) -> float: ...
@overload
def standard_exponential(size: _Size) -> ndarray: ...
@overload
def standard_gamma(size: None = ...) -> float: ...
@overload
def standard_gamma(size: _Size) -> ndarray: ...
@overload
def standard_normal(size: None = ...) -> float: ...
@overload
def standard_normal(size: _Size) -> ndarray: ...
@overload
def standard_t(t: int, size: None = ...) -> float: ...
@overload
def standard_t(t: _ScalarOrArray[int], size: _Size) -> ndarray: ...
@overload
def standard_t(t: _ArrayLike[int], size: None = ...) -> ndarray: ...
@overload
def tomaxint(t: int, size: None = ...) -> int: ...
@overload
def tomaxint(t: _ScalarOrArray[int], size: _Size) -> ndarray: ...
@overload
def tomaxint(t: _ArrayLike[int], size: None = ...) -> ndarray: ...
@overload
def triangular(
    left: float, mode: float, right: float, size: None = ...
) -> float: ...
@overload
def triangular(
    left: _ScalarOrArray[float],
    mode: _ScalarOrArray[float],
    right: _ScalarOrArray[float],
    size: _Size,
) -> ndarray: ...
@overload
def triangular(
    left: _ArrayLike[float], mode: float, right: float, size: None = ...
) -> ndarray: ...
@overload
def triangular(
    left: float, mode: _ArrayLike[float], right: float, size: None = ...
) -> ndarray: ...
@overload
def triangular(
    left: float, mode: float, right: _ArrayLike[float], size: None = ...
) -> ndarray: ...
@overload
def triangular(
    left: _ArrayLike[float],
    mode: _ArrayLike[float],
    right: float,
    size: None = ...,
) -> ndarray: ...
@overload
def triangular(
    left: _ArrayLike[float],
    mode: float,
    right: _ArrayLike[float],
    size: None = ...,
) -> ndarray: ...
@overload
def triangular(
    left: float,
    mode: _ArrayLike[float],
    right: _ArrayLike[float],
    size: None = ...,
) -> ndarray: ...
@overload
def triangular(
    left: _ArrayLike[float],
    mode: _ArrayLike[float],
    right: _ArrayLike[float],
    size: None = ...,
) -> ndarray: ...
@overload
def uniform(
    low: float = ..., high: float = ..., size: None = ...
) -> float: ...
@overload
def uniform(
    low: _ScalarOrArray[float], high: _ScalarOrArray[float], size: _Size
) -> ndarray: ...
@overload
def uniform(
    low: _ArrayLike[float], high: float, size: None = ...
) -> ndarray: ...
@overload
def uniform(
    low: float, high: _ArrayLike[float], size: None = ...
) -> ndarray: ...
@overload
def uniform(
    low: _ArrayLike[float], high: _ArrayLike[float], size: None = ...
) -> ndarray: ...
@overload
def vonmises(mu: float, kappa: float, size: None = ...) -> float: ...
@overload
def vonmises(
    mu: _ScalarOrArray[float], kappa: _ScalarOrArray[float], size: _Size
) -> ndarray: ...
@overload
def vonmises(
    mu: _ArrayLike[float], kappa: float, size: None = ...
) -> ndarray: ...
@overload
def vonmises(
    mu: float, kappa: _ArrayLike[float], size: None = ...
) -> ndarray: ...
@overload
def vonmises(
    mu: _ArrayLike[float], kappa: _ArrayLike[float], size: None = ...
) -> ndarray: ...
@overload
def wald(mean: float, scale: float, size: None = ...) -> float: ...
@overload
def wald(
    mean: _ScalarOrArray[float], scale: _ScalarOrArray[float], size: _Size
) -> ndarray: ...
@overload
def wald(
    mean: _ArrayLike[float], scale: float, size: None = ...
) -> ndarray: ...
@overload
def wald(
    mean: float, scale: _ArrayLike[float], size: None = ...
) -> ndarray: ...
@overload
def wald(
    mean: _ArrayLike[float], scale: _ArrayLike[float], size: None = ...
) -> ndarray: ...
@overload
def weibull(a: float, size: None = ...) -> float: ...
@overload
def weibull(a: _ScalarOrArray[float], size: _Size) -> ndarray: ...
@overload
def weibull(a: _ArrayLike[float], size: None = ...) -> ndarray: ...
@overload
def zipf(a: float, size: None = ...) -> int: ...
@overload
def zipf(a: _ScalarOrArray[float], size: _Size) -> ndarray: ...
@overload
def zipf(a: _ArrayLike[float], size: None = ...) -> ndarray: ...
